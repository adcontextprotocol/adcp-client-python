# Upstream Schema Recommendations for AdCP

**Status Update (2025-11-20)**: ðŸŽ‰ðŸŽ‰ðŸŽ‰ **ALL RESOLVED!**
- PR #222 (merged): Enum collisions fixed
- PR #223 (open): Package collision fixed via response unification

## Problem Statement

The AdCP schemas contain type name collisions that create challenges for downstream SDK implementations. When multiple schema files define enums or classes with identical names but different semantics, code generators cannot automatically distinguish between them, forcing SDKs to either:

1. Use internal "qualified imports" with workarounds (brittle, non-intuitive)
2. Export only one variant through the stable API (breaks use cases needing the other variant)
3. Require users to import from unstable internal paths (defeats type safety goals)

This document identifies the specific collisions and recommends upstream schema changes.

## Identified Collisions

### Summary Status

| Collision | Status | Resolution |
|-----------|--------|------------|
| AssetType enum | âœ… Resolved | PR #222 (merged): Consolidated to `AssetContentType` |
| Type enum | âœ… Resolved | PR #222 (merged): Split into `AssetContentType` + `FormatCategory` |
| Package class | âœ… Resolved | PR #223 (open): Unified responses to return full Package |

### 1. Package Type Collision (âœ… RESOLVED via PR #223)

**Issue**: Two different `Package` types serve distinct purposes:

- **Request Package** (`package.json`): Full package definition with 12 fields including status, creative assignments, targeting overlay
  - Used in: Media buy state tracking, package updates, get operations
  - Fields: `package_id`, `buyer_ref`, `status`, `budget`, `bid_price`, `impressions`, `product_id`, `pricing_option_id`, `creative_assignments`, `format_ids_to_provide`, `pacing`, `targeting_overlay`

- **Response Package** (`create-media-buy-response.json`): Minimal package reference with 2 fields
  - Used in: CreateMediaBuy success responses
  - Fields: `package_id`, `buyer_ref`

**Current Workaround**:
```python
# stable.py exports the full request Package
from adcp.types._generated import _PackageFromPackage as Package

# Response Package is not exported, requiring:
from adcp.types.generated_poc.create_media_buy_response import Package
```

**Impact**: Users building CreateMediaBuy response handlers cannot use stable API types.

**Resolution (PR #223 - Better than our proposal!):**

Instead of splitting into `PackageStatus` + `PackageReference` as we proposed, PR #223 **unifies responses** to always return full Package objects:

```json
// create-media-buy-response.json - NOW returns full Package
{
  "packages": [{
    "package_id": "pkg_001",
    "buyer_ref": "package_ref",
    "product_id": "ctv_premium",
    "budget": 50000,
    "status": "active",
    "pacing": "even",
    "pricing_option_id": "cpm-fixed",
    "creative_assignments": [],
    "format_ids_to_provide": []
  }]
}
```

**Benefits of this approach:**
- âœ… Eliminates collision (only one Package type)
- âœ… Improves API consistency (create and update return same structure)
- âœ… Better developer experience (full state without follow-up calls)
- âœ… Backward compatible (additive change only)

### 2. AssetType Enum Collision (âœ… RESOLVED in PR #222)

**Issue**: Three different `AssetType` enums with overlapping but distinct value sets:

- **asset-type.json** (11 values): `image`, `video`, `audio`, `text`, `html`, `css`, `javascript`, `vast`, `daast`, `promoted_offerings`, `url`
  - Context: Asset specifications in format definitions

- **list-creative-formats-request.json** (7 values): `image`, `video`, `audio`, `text`, `html`, `javascript`, `url`
  - Context: Filtering formats by asset requirements
  - Missing: `css`, `vast`, `daast`, `promoted_offerings`

- **brand-manifest.json** (4 values): `image`, `video`, `audio`, `text`
  - Context: Brand asset library items
  - Missing: All markup/code types, structured ad formats

**Current Workaround**:
```python
# stable.py exports asset-type.json's version (alphabetically first)
from adcp.types.stable import AssetType

# Other variants require internal imports:
from adcp.types.generated_poc.list_creative_formats_request import AssetType
from adcp.types.generated_poc.brand_manifest import AssetType
```

**Impact**: Users calling `list_creative_formats` with asset_types filter cannot use stable API enums.

**Resolution (PR #222)**:
- Created `/schemas/v1/enums/asset-content-type.json` with 13 canonical values
- All schemas now reference this via `$ref`
- Single `AssetContentType` enum generated by all SDKs
- No more collisions or workarounds needed

### 3. Type Enum Collision (âœ… RESOLVED in PR #222)

**Issue**: Two different `Type` enums serving different categorization purposes:

- **asset-type.json** (11 values): Asset MIME/content types
  - Values: `image`, `video`, `audio`, `text`, `html`, `css`, `javascript`, `vast`, `daast`, `promoted_offerings`, `url`
  - Context: What kind of content an asset contains

- **format.json** (7 values): Creative format categories
  - Values: `audio`, `video`, `display`, `native`, `dooh`, `rich_media`, `universal`
  - Context: Advertising channel/placement type

- **list-creative-formats-request.json** (4 values): Format filtering categories
  - Values: `audio`, `video`, `display`, `dooh`
  - Context: Filter parameter for format listings
  - Missing: `native`, `rich_media`, `universal`

**Current Workaround**:
```python
# stable.py exports asset-type.json's Type (alphabetically first)
from adcp.types.stable import Type  # Asset type, not format type!

# Format.type enum requires internal import:
from adcp.types.generated_poc.format import Type as FormatType

# ListCreativeFormatsRequest.type filter requires internal import:
from adcp.types.generated_poc.list_creative_formats_request import Type as FilterType
```

**Impact**: Users working with Format objects or filtering formats cannot use stable API types.

**Resolution (PR #222)**:
- Created `/schemas/v1/enums/format-category.json` (7 values: audio, video, display, native, dooh, rich_media, universal)
- `format.json` now references `FormatCategory` enum
- `list-creative-formats-request.json` references full `FormatCategory` (no subsets)
- `AssetContentType` remains for asset content types
- Clear separation: content types vs. format categories

## Recommended Solutions

**Note**: PR #222 implemented Option A (Unique Naming) for enum collisions. Package collision remains.

### Option A: Unique Naming (Quick Fix)

Rename types in schemas to be self-descriptive:

#### 1. Package Types
```json
// package.json
"PackageStatus": { ... }  // Rename class from Package

// create-media-buy-response.json
"PackageReference": {     // Rename class from Package
  "properties": {
    "package_id": { ... },
    "buyer_ref": { ... }
  }
}
```

**Rationale**: "PackageStatus" accurately describes the full state object. "PackageReference" clearly indicates a lightweight identifier.

#### 2. AssetType Enums

**Analysis**: These may actually be a versioning issue rather than distinct types. The schemas describe the same concept (asset content types) with different completeness levels.

**Recommendation**: Consolidate into single canonical enum:

```json
// asset-types.json (new shared schema)
{
  "$id": "asset-types.json",
  "AssetType": {
    "enum": [
      "image", "video", "audio", "text",
      "html", "css", "javascript",
      "vast", "daast",
      "promoted_offerings",
      "url", "markdown", "webhook"
    ]
  }
}
```

Then reference via `$ref` from:
- `asset-type.json`
- `brand-manifest.json` (may allow subset for brand library)
- `list-creative-formats-request.json` (may allow subset for filtering)
- `format.json`

**If subsets are intentional**: Use descriptive names:
- `BrandAssetType`: Brand library assets (image, video, audio, text)
- `CreativeFormatAssetType`: Format specifications (all 13 values)
- `AssetTypeFilter`: Format filtering (7 queryable values)

#### 3. Type Enums

These represent genuinely different concepts:

```json
// asset-type.json
"AssetContentType": {  // Rename from Type
  "enum": ["image", "video", "audio", ...]
}

// format.json
"FormatCategory": {    // Rename from Type
  "enum": ["audio", "video", "display", "native", "dooh", "rich_media", "universal"]
}

// list-creative-formats-request.json
"FormatCategoryFilter": {  // Rename from Type
  "enum": ["audio", "video", "display", "dooh"]
}
```

**Rationale**:
- "AssetContentType" describes what the asset IS
- "FormatCategory" describes the advertising channel/placement
- "FormatCategoryFilter" describes the query subset

### Option B: Schema Consolidation (Best Long-term)

Refactor schemas to eliminate redundancy:

1. **Shared definitions file**: Create `common-types.json` with canonical enums
2. **Use $ref everywhere**: All schemas reference canonical definitions
3. **Version enums explicitly**: If subsets are intentional, document why

Example:
```json
// common-types.json
{
  "definitions": {
    "AssetType": { "enum": [...] },
    "FormatCategory": { "enum": [...] },
    "PackageReference": { ... },
    "PackageStatus": { ... }
  }
}

// format.json
{
  "properties": {
    "type": { "$ref": "common-types.json#/definitions/FormatCategory" }
  }
}
```

## Priority Recommendations

### High Priority (Breaks stable API usage)

1. **Package collision**: Rename to `PackageStatus` and `PackageReference`
   - Impact: CreateMediaBuy response handling currently impossible with stable API
   - Complexity: Low (rename in 2 schema files)

2. **Format Type collision**: Rename to `FormatCategory`
   - Impact: Working with Format.type field requires unstable imports
   - Complexity: Low (rename in 2 schema files + update 1 reference)

### Medium Priority (Workaround exists but fragile)

3. **AssetType consolidation**: Merge into single canonical enum or namespace variants
   - Impact: Format filtering and brand manifest usage require unstable imports
   - Complexity: Medium (decide if differences are intentional, update 3+ schemas)

## Migration Path

If schema changes are accepted:

1. **AdCP 2.9.0**: Publish schemas with new names
2. **SDK transitional version**: Export both old and new names with deprecation warnings
3. **SDK breaking version**: Remove old names, complete migration

Example SDK migration:
```python
# adcp 2.9.x - Transitional
from adcp.types import (
    Package,           # Deprecated: Use PackageStatus
    PackageStatus,     # New name
    PackageReference,  # New name
)

# adcp 3.0.0 - Clean
from adcp.types import (
    PackageStatus,
    PackageReference,
)
```

## Questions for AdCP Team

1. **AssetType differences**: Are the different AssetType enums intentional (different valid subsets) or incomplete schema evolution?

2. **Enum versioning strategy**: Should we version enums when adding values (AssetTypeV1, AssetTypeV2) or maintain single growing enum?

3. **Breaking change policy**: Can we coordinate schema renames in AdCP 2.9 or should we wait for 3.0?

4. **Common types file**: Would AdCP benefit from a `common-types.json` with shared definitions?

## Appendix: Full Type Definitions

### Package (package.json) - Full State
```typescript
interface Package {
  package_id: string;
  buyer_ref: string | null;
  status: PackageStatus;
  budget: number | null;
  bid_price: number | null;
  impressions: number | null;
  product_id: string | null;
  pricing_option_id: string | null;
  creative_assignments: CreativeAssignment[] | null;
  format_ids_to_provide: FormatId[] | null;
  pacing: Pacing | null;
  targeting_overlay: TargetingOverlay | null;
}
```

### Package (create-media-buy-response.json) - Reference
```typescript
interface Package {
  package_id: string;
  buyer_ref: string;
}
```

### AssetType Comparison

| Value | asset-type.json | brand-manifest.json | list-creative-formats-request.json | format.json |
|-------|----------------|---------------------|-----------------------------------|-------------|
| image | âœ“ | âœ“ | âœ“ | âœ“ |
| video | âœ“ | âœ“ | âœ“ | âœ“ |
| audio | âœ“ | âœ“ | âœ“ | âœ“ |
| text | âœ“ | âœ“ | âœ“ | âœ“ |
| html | âœ“ | âœ— | âœ“ | âœ“ |
| css | âœ“ | âœ— | âœ— | âœ“ |
| javascript | âœ“ | âœ— | âœ“ | âœ“ |
| vast | âœ“ | âœ— | âœ— | âœ“ |
| daast | âœ“ | âœ— | âœ— | âœ“ |
| promoted_offerings | âœ“ | âœ— | âœ— | âœ“ |
| url | âœ“ | âœ— | âœ“ | âœ“ |
| markdown | âœ— | âœ— | âœ— | âœ“ |
| webhook | âœ— | âœ— | âœ— | âœ“ |

### Type Enum Comparison

| Value | asset-type.json (Asset content) | format.json (Format category) | list-creative-formats-request.json (Filter) |
|-------|--------------------------------|------------------------------|-------------------------------------------|
| image | âœ“ | âœ— | âœ— |
| video | âœ“ | âœ“ | âœ“ |
| audio | âœ“ | âœ“ | âœ“ |
| text | âœ“ | âœ— | âœ— |
| html | âœ“ | âœ— | âœ— |
| css | âœ“ | âœ— | âœ— |
| javascript | âœ“ | âœ— | âœ— |
| vast | âœ“ | âœ— | âœ— |
| daast | âœ“ | âœ— | âœ— |
| promoted_offerings | âœ“ | âœ— | âœ— |
| url | âœ“ | âœ— | âœ— |
| display | âœ— | âœ“ | âœ“ |
| native | âœ— | âœ“ | âœ— |
| dooh | âœ— | âœ“ | âœ“ |
| rich_media | âœ— | âœ“ | âœ— |
| universal | âœ— | âœ“ | âœ— |

---

**Document Version**: 1.0
**Date**: 2025-11-19
**SDK**: adcp-client-python 2.8.0
**Schema Version**: AdCP protocol schemas as of 2025-11-18
