# Python SDK Development Learnings

## Type Safety & Code Generation

**Auto-generate from specs when possible**
- Download schemas from canonical source (e.g., adcontextprotocol.org/schemas)
- Generate Pydantic models automatically - keeps types in sync with spec
- Validate generated code in CI (syntax check + import test)
- For missing upstream types, add type aliases with clear comments explaining why

**Handling Missing Schema Types**
When schemas reference types that don't exist upstream:
```python
# MISSING SCHEMA TYPES (referenced but not provided by upstream)
# These types are referenced in schemas but don't have schema files
FormatId = str
PackageRequest = dict[str, Any]
```

**Stable Public API Layer - Import Architecture**

**CRITICAL**: Both `generated_poc/` and `_generated.py` are internal implementation. Source code must ONLY import from `stable.py` or `aliases.py`.

### Import Architecture

The type system has a strict layering to prevent brittleness:

```
generated_poc/*.py (internal, auto-generated from schemas)
    ↓
_generated.py (internal consolidation, handles name collisions)
    ↓
stable.py (public API for base types) + aliases.py (public API for discriminated unions)
    ↓
__init__.py (user-facing exports)
```

### Import Rules for Source Code

**✅ CORRECT - Public API only:**
```python
# For base types (requests, responses, domain models)
from adcp.types.stable import (
    GetProductsRequest,
    GetProductsResponse,
    Product,
    Package,
    BrandManifest,
)

# For semantic aliases (discriminated unions)
from adcp.types.aliases import (
    CreateMediaBuySuccessResponse,
    CreateMediaBuyErrorResponse,
    PreviewCreativeFormatRequest,
)

# Or from main package
from adcp import Product, CreateMediaBuySuccessResponse
```

**❌ WRONG - Internal implementation (brittle):**
```python
# Never import from _generated - it's internal consolidation
from adcp.types._generated import GetProductsRequest

# Never import from generated_poc - it's internal generated code
from adcp.types.generated_poc.product import Product

# Never import numbered types directly - use semantic aliases
from adcp.types._generated import CreateMediaBuyResponse1
```

### Why This Matters

1. **`generated_poc/`** may have:
   - Numbered suffixes (e.g., `Response1`, `Response2`)
   - Files added/removed as schemas evolve
   - Name collisions between modules

2. **`_generated.py`** may have:
   - Collision-resolution qualifiers (e.g., `_PackageFromPackage`)
   - Internal consolidation logic
   - Changes when collision handling evolves

3. **`stable.py` and `aliases.py`** provide:
   - Clean, semantic names
   - Stability guarantees within major versions
   - Explicit public API

### Special Cases

**Only `stable.py` and `aliases.py` may import from `_generated.py`:**
- `stable.py`: Imports base types and re-exports with clean names
- `aliases.py`: Imports numbered discriminated union types and creates semantic aliases

**All other source files must import from `stable.py` or `aliases.py`.**

**NEVER Modify Generated Files Directly**

Files in `src/adcp/types/generated_poc/` and `src/adcp/types/generated.py` are auto-generated by `scripts/generate_types.py`. Any manual edits will be lost on regeneration.

**CRITICAL**: Do not add code to `generated.py` or any files in `generated_poc/` directory. These are regenerated from schemas.

**Post-Generation Fix System:**

We use `scripts/post_generate_fixes.py` which runs automatically after type generation to apply necessary modifications that can't be generated.

**Preventing Stale Files:**

The generation script (`scripts/generate_types.py`) **deletes the entire output directory** before regenerating types. This prevents stale files from persisting when schemas are renamed or removed. Without this, old generated files could remain checked in indefinitely, causing import errors and confusion about which types are actually current.

**Avoiding Noisy Commits:**

After generation, the script automatically restores files where only the timestamp changed (e.g., `#   timestamp: 2025-11-18T03:32:03+00:00`). This prevents commits with 100+ file changes where the only difference is the generation timestamp, making actual changes easier to review.

**Type Name Collisions:**

The upstream AdCP schemas define multiple types with the same name (e.g., `Contact`, `Asset`, `Status`) in different schema files. These are **genuinely different types** with different fields, not duplicates.

When consolidating exports in `generated.py`, we use a "first wins" strategy (alphabetical by module name) and warn about collisions. Users can still access all versions via module-qualified imports:

```python
# Access the "winning" version
from adcp.types._generated import Asset

# Access specific versions
from adcp.types.generated_poc.brand_manifest import Asset as BrandAsset
from adcp.types.generated_poc.format import Asset as FormatAsset
```

**Upstream Issue:** This should ideally be fixed in the AdCP schema definitions by either:
- Using unique names (e.g., `BrandAsset` vs `FormatAsset`)
- Sharing common types via `$ref`
- Using discriminated unions where appropriate

**Current fixes applied:**

1. **Self-referential types** - Fixes `preview_render.py` if it contains module-qualified self-references

2. **Forward references** - Fixes BrandManifest imports in:
   - `promoted_offerings.py`
   - `create_media_buy_request.py`
   - `get_products_request.py`

3. **~~Publisher properties validation~~ (DEPRECATED)** - After PR #213 added explicit discriminator to `publisher_properties` schema, Pydantic now generates proper discriminated union variants (`PublisherProperties`, `PublisherProperties4`, `PublisherProperties5`) with automatic validation. Manual validator injection is no longer needed.

**Note on Pricing Options:**

The code generator creates individual files for each pricing option (e.g., `cpm_fixed_option.py`, `cpm_auction_option.py`) with the `is_fixed` discriminator field already included:
- Fixed-rate options: `is_fixed: Annotated[Literal[True], ...]`
- Auction options: `is_fixed: Annotated[Literal[False], ...]`

These are used via union types in `Product.pricing_options`. No post-generation fix is needed for pricing options.

**To add new post-generation fixes:**
Edit `scripts/post_generate_fixes.py` and add a new function. The script:
- Runs automatically via `generate_types.py`
- Is idempotent (safe to run multiple times)
- Validates fixes were successfully applied
- Fails loudly if schema changes break the fix patterns

## Semantic Type Aliases for Discriminated Unions

**Problem**: The code generator (`datamodel-code-generator`) creates numbered type names for discriminated union variants (e.g., `PreviewRender1`, `PreviewRender2`, `SubAsset1`, `SubAsset2`). While functionally correct, these don't convey semantic meaning.

**Solution**: Add semantic type aliases in `src/adcp/types/aliases.py` that provide clear, descriptive names based on the discriminator field value.

**Process for Adding New Semantic Aliases:**

1. **Identify the discriminated union types** - Look for numbered types (e.g., `TypeName1`, `TypeName2`) in generated files
2. **Determine the discriminator field** - Check the schema/generated code for the `Literal` field that distinguishes variants
3. **Create semantic aliases in `aliases.py`**:
   ```python
   # Import the generated types
   from adcp.types._generated import PreviewRender1, PreviewRender2, PreviewRender3

   # Create semantic aliases based on discriminator values
   UrlPreviewRender = PreviewRender1  # output_format='url'
   HtmlPreviewRender = PreviewRender2  # output_format='html'
   BothPreviewRender = PreviewRender3  # output_format='both'
   ```

4. **Add to exports** in `aliases.py`:
   ```python
   __all__ = [
       ...,
       "UrlPreviewRender",
       "HtmlPreviewRender",
       "BothPreviewRender",
   ]
   ```

5. **Re-export from main package** in `src/adcp/__init__.py`:
   ```python
   from adcp.types.aliases import (
       ...,
       UrlPreviewRender,
       HtmlPreviewRender,
       BothPreviewRender,
   )

   __all__ = [
       ...,
       "UrlPreviewRender",
       "HtmlPreviewRender",
       "BothPreviewRender",
   ]
   ```

6. **Add comprehensive tests** in `tests/test_type_aliases.py`:
   - Test that aliases can be imported
   - Test that aliases point to correct generated types
   - Test that aliases are exported from main package

**Current Semantic Aliases (Complete Coverage - 30 user-facing types):**

- **Preview Renders** (discriminated by `output_format`):
  - `UrlPreviewRender` = `PreviewRender1` (output_format='url')
  - `HtmlPreviewRender` = `PreviewRender2` (output_format='html')
  - `BothPreviewRender` = `PreviewRender3` (output_format='both')

- **VAST Assets** (discriminated by `delivery_type`):
  - `UrlVastAsset` = `VastAsset1` (delivery_type='url')
  - `InlineVastAsset` = `VastAsset2` (delivery_type='inline')

- **DAAST Assets** (discriminated by `delivery_type`):
  - `UrlDaastAsset` = `DaastAsset1` (delivery_type='url')
  - `InlineDaastAsset` = `DaastAsset2` (delivery_type='inline')

- **SubAssets** (discriminated by `asset_kind`):
  - `MediaSubAsset` = `SubAsset1` (asset_kind='media')
  - `TextSubAsset` = `SubAsset2` (asset_kind='text')

- **Response Types** (discriminated by success/error):
  - Success/Error variants for: ActivateSignal, BuildCreative, CreateMediaBuy, ProvidePerformanceFeedback, SyncCreatives, UpdateMediaBuy

- **Request Types** (discriminated by operation variant):
  - `PreviewCreativeFormatRequest`/`PreviewCreativeManifestRequest`
  - `UpdateMediaBuyPackagesRequest`/`UpdateMediaBuyPropertiesRequest`

- **Activation Keys** (discriminated by identifier type):
  - `PropertyIdActivationKey`/`PropertyTagActivationKey`

- **Publisher Properties** (discriminated by `selection_type`):
  - `PublisherPropertiesAll` = `PublisherProperties` (selection_type='all')
  - `PublisherPropertiesById` = `PublisherProperties4` (selection_type='by_id')
  - `PublisherPropertiesByTag` = `PublisherProperties5` (selection_type='by_tag')
  - Also exports: `PropertyId`, `PropertyTag` (constraint types)

- **Deployment Types** (discriminated by `type`):
  - `PlatformDeployment` = `Deployment1` (type='platform')
  - `AgentDeployment` = `Deployment2` (type='agent')

- **Destination Types** (discriminated by `type`):
  - `PlatformDestination` = `Destination1` (type='platform')
  - `AgentDestination` = `Destination2` (type='agent')

**Internal Types NOT Aliased (15 types):**
- Nested helper types: `Input2`, `Input4`, `Response1`, `Results1`, `Preview1`, etc.
- Package update internals: `Packages1`, `Packages2`, `Packages3`
- Format helpers: `AssetsRequired1`, `ViewThreshold1`
- Internal enums: `Field1`, `Method1`

**Note on Pricing Types:**

Pricing option types (`CpcPricingOption`, `CpmAuctionPricingOption`, `CpmFixedRatePricingOption`, etc.) already have clear semantic names from the schema generator, so they don't need aliases. These types now include an `is_fixed` discriminator:
- Fixed-rate pricing: `is_fixed=Literal[True]` (CPC, CPCV, CPM Fixed, vCPM Fixed, Flat Rate)
- Auction-based pricing: `is_fixed=Literal[False]` (CPM Auction, vCPM Auction)

**Guidelines for Choosing What to Alias:**

✅ **DO create aliases for:**
- User-facing discriminated unions used in API calls
- Types where the discriminator conveys important semantic meaning
- Types where numbered suffixes cause confusion
- Types that appear in union fields of Product, MediaBuy, Package
- Request/Response variants users construct or pattern-match

❌ **DON'T create aliases for:**
- Internal helper types not commonly used directly
- Types where parent context makes the meaning clear
- Generic helper types (Input2, Parameters2, etc.)
- Nested container types in requests/responses
- Internal enums (Field1, Method1)

## Preventing Direct Imports from generated_poc

**Goal**: Ensure downstream users NEVER have to import from `generated_poc` or use numbered types.

### Strategy 1: Complete Aliasing Coverage

**After regenerating types**, audit for new discriminated unions:

```bash
# Find all numbered types in generated code
grep -h "^class.*[0-9](" src/adcp/types/generated_poc/*.py | \
  sed 's/class \([^(]*\).*/\1/' | sort -u

# For each numbered type, determine if it needs an alias:
# 1. Is it used in a Union[] in Product/MediaBuy/Package? → YES, alias it
# 2. Is it a Request/Response variant? → YES, alias it
# 3. Does it have a discriminator field (Literal type)? → Probably YES
# 4. Is it only used internally (Input2, Results1)? → NO, skip it
```

### Strategy 2: Automated Detection

Add `scripts/check_missing_aliases.py`:

```python
"""Check for user-facing numbered types without semantic aliases."""
import ast
import re
from pathlib import Path

def find_discriminated_unions():
    """Find types with discriminator fields that need aliases."""
    generated_dir = Path("src/adcp/types/generated_poc")
    numbered_types = set()

    for py_file in generated_dir.glob("*.py"):
        content = py_file.read_text()
        # Find class definitions ending in digits
        matches = re.findall(r"class (\w+\d+)\(", content)
        # Check if they have Literal discriminators
        for match in matches:
            if f"Literal[" in content:  # Has discriminator
                numbered_types.add(match)

    # Check which are already aliased
    aliases_file = Path("src/adcp/types/aliases.py")
    aliases_content = aliases_file.read_text()

    missing = []
    for typename in numbered_types:
        if f"= {typename}" not in aliases_content:
            missing.append(typename)

    return missing

if __name__ == "__main__":
    missing = find_discriminated_unions()
    if missing:
        print(f"❌ Found {len(missing)} numbered types without aliases:")
        for t in missing:
            print(f"  - {t}")
        exit(1)
    else:
        print("✅ All user-facing types have semantic aliases")
```

### Strategy 3: CI Enforcement

Add to `.github/workflows/ci.yml`:

```yaml
- name: Check for missing type aliases
  run: uv run python scripts/check_missing_aliases.py
```

### Strategy 4: Import Linting

Add custom ruff rule or pre-commit hook:

```python
# .pre-commit-config.yaml or custom linter
# Detect imports from generated_poc in user code
def check_generated_imports(file_path: str) -> list[str]:
    """Warn about direct generated_poc imports."""
    if "test_" in file_path or "aliases.py" in file_path:
        return []  # Allow in tests and aliases module

    with open(file_path) as f:
        for line_no, line in enumerate(f, 1):
            if "from adcp.types.generated_poc" in line:
                return [f"{file_path}:{line_no}: Don't import from generated_poc - use semantic aliases"]
    return []
```

### Strategy 5: Documentation

**In type regeneration workflow**, always check:

1. Run type generation: `uv run python scripts/generate_types.py`
2. Check for new numbered types: `scripts/check_missing_aliases.py`
3. If new types found:
   - Determine discriminator field
   - Add semantic alias in `aliases.py`
   - Export from `__init__.py`
   - Add tests in `test_type_aliases.py`
4. Commit with descriptive message explaining the discriminator

**Type Checking Best Practices**
- Use `TYPE_CHECKING` for optional dependencies to avoid runtime import errors
- Use `cast()` for JSON deserialization to satisfy mypy's `no-any-return` checks
- Add specific `type: ignore` comments (e.g., `# type: ignore[no-any-return]`) rather than blanket ignores
- Test type checking in CI across multiple Python versions (3.10+)

## Testing Strategy

**Mock at the Right Level**
- For HTTP clients: Mock `_get_client()` method, not the httpx class directly
- For async operations: Use `AsyncMock` for async functions, `MagicMock` for sync methods
- Remember: httpx's `response.json()` is SYNCHRONOUS, not async

**Test API Changes Properly**
- When API changes from kwargs to typed objects, update tests to match
- Remove tests for non-existent methods rather than keep failing tests
- Test the API as it exists, not as we wish it existed

## CI/CD & Release Automation

**GitHub Actions Secrets**
- Secret names matter! Check actual secret name in repository settings
- Common pattern: `PYPY_API_TOKEN` (not `PYPI_API_TOKEN`) for PyPI publishing
- Test locally with `python -m build` before relying on CI

**Release Please Workflow**
- Runs automatically on push to main
- Creates release PR with version bump and changelog
- When release PR is merged, automatically publishes to PyPI
- Requires proper `[project.scripts]` entry point in pyproject.toml for CLI tools

**Entry Points for CLI Tools**
```toml
[project.scripts]
toolname = "package.__main__:main"
```
This enables `uvx toolname` and `pip install toolname` to work correctly.

## Development Environment & Tools

**Using uv for Package Management**

This project uses `uv` for fast, reliable Python package management. ALWAYS use `uv` commands rather than bare `python` or `pip`:

```bash
# Install dependencies (including dev dependencies)
uv sync --extra dev

# Run scripts with the virtual environment
uv run pytest                        # Run tests
uv run python scripts/sync_schemas.py    # Sync schemas
uv run python scripts/generate_types.py  # Generate types

# Activate the virtual environment (if needed for multiple commands)
source .venv/bin/activate
# OR use .venv/bin/python directly
.venv/bin/python scripts/generate_types.py
```

**Schema Update Workflow**

When pulling in updated schemas from upstream:

1. **Sync schemas**: `python3 scripts/sync_schemas.py` (no venv needed, uses stdlib)
   - Downloads latest schemas from AdCP GitHub
   - Uses content hashing to only update changed schemas
   - Updates `schemas/cache/.hashes.json` for tracking

2. **Generate types**: `uv run python scripts/generate_types.py` (requires dev dependencies)
   - Requires `datamodel-code-generator` from dev dependencies
   - Regenerates all Pydantic models from schemas
   - Runs post-generation fixes automatically
   - Consolidates exports into `generated.py`

3. **Verify changes**: `uv run pytest`
   - All 258+ tests should pass
   - Verifies backward compatibility

4. **Review for semantic aliases**: Check if new discriminated unions need aliases
   - Look for numbered types (Type1, Type2) in generated files
   - Add semantic aliases to `src/adcp/types/aliases.py` if needed
   - Update exports in `src/adcp/__init__.py`
   - Add tests in `tests/test_type_aliases.py`

**Important**: The sync_schemas.py script uses only Python stdlib (urllib, json, pathlib) and doesn't require the virtual environment. The generate_types.py script requires dev dependencies and must use `uv run` or the venv python.

## Python-Specific Patterns

**Optional Dependencies with TYPE_CHECKING**
```python
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from optional_lib import SomeType

try:
    from optional_lib import SomeType as _SomeType
    AVAILABLE = True
except ImportError:
    AVAILABLE = False
```

**Atomic File Operations**
For config files with sensitive data:
```python
temp_file = CONFIG_FILE.with_suffix(".tmp")
with open(temp_file, "w") as f:
    json.dump(config, f, indent=2)
temp_file.replace(CONFIG_FILE)  # Atomic rename
```

**Connection Pooling**
```python
# Reuse HTTP client across requests
self._client: httpx.AsyncClient | None = None

async def _get_client(self) -> httpx.AsyncClient:
    if self._client is None:
        limits = httpx.Limits(
            max_keepalive_connections=10,
            max_connections=20,
        )
        self._client = httpx.AsyncClient(limits=limits)
    return self._client
```

**Format Definition Caching (Production Consideration)**

Creative formats rarely change, so production implementations should cache format definitions to avoid redundant `list_creative_formats` calls:

```python
from functools import lru_cache

# Option 1: Simple LRU cache for format lookups
@lru_cache(maxsize=100)
async def get_format_definition(agent_url: str, format_id: str) -> Format:
    """Cached format definition lookup."""
    agent = get_agent_for_url(agent_url)
    result = await agent.list_creative_formats()
    for fmt in result.data.formats:
        if fmt.format_id.id == format_id:
            return fmt
    raise ValueError(f"Format not found: {format_id}")

# Option 2: TTL-based cache with periodic refresh
class FormatCache:
    def __init__(self, ttl_seconds: int = 3600):
        self._cache: dict[tuple[str, str], tuple[Format, float]] = {}
        self._ttl = ttl_seconds

    async def get_format(self, agent_url: str, format_id: str) -> Format:
        """Get format with TTL-based caching."""
        key = (agent_url, format_id)
        if key in self._cache:
            fmt, timestamp = self._cache[key]
            if time.time() - timestamp < self._ttl:
                return fmt

        # Cache miss or expired - fetch fresh
        fmt = await self._fetch_format(agent_url, format_id)
        self._cache[key] = (fmt, time.time())
        return fmt
```

**Cache Invalidation Strategies:**
1. **TTL-based** (recommended): Formats rarely change, 1-hour TTL is reasonable
2. **Version-based**: Use format version in ID (e.g., `banner_300x250_v2`)
3. **ETags**: Check `Last-Modified` headers if agents support it
4. **Explicit invalidation**: Clear cache when format changes detected

## Common Pitfalls to Avoid

**String Escaping in Code Generation**
Always escape in this order:
1. Backslashes first: `\\` → `\\\\`
2. Then quotes: `"` → `\"`
3. Then control chars (newlines, tabs)

Wrong order creates invalid escape sequences!

**Python Version Requirements**
- Union syntax `str | None` requires Python 3.10+
- Always include `from __future__ import annotations` at top of files
- Use `target-version = "py310"` in ruff/black config
- Test in CI across all supported Python versions

**Test Fixtures vs. Mocks**
- Don't over-mock - it hides serialization bugs
- Test actual API calls when possible
- Use real Pydantic validation in tests
- Mock external services, not internal logic

## Additional Important Reminders

**NEVER**:
- Assume a "typo" without checking the actual secret name in GitHub settings

**ALWAYS**:
- Verify secret names match repository settings before "fixing" them
