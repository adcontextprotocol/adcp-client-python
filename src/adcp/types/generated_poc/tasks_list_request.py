# generated by datamodel-codegen:
#   filename:  tasks-list-request.json
#   timestamp: 2025-11-15T17:41:28+00:00

from __future__ import annotations

from enum import Enum
from typing import Any

from adcp.types.base import AdCPBaseModel
from pydantic import AwareDatetime, ConfigDict, Field


class Domain(Enum):
    media_buy = 'media-buy'
    signals = 'signals'


class FieldModel(Enum):
    created_at = 'created_at'
    updated_at = 'updated_at'
    status = 'status'
    task_type = 'task_type'
    domain = 'domain'


class Direction(Enum):
    asc = 'asc'
    desc = 'desc'


class Sort(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    field: FieldModel | None = Field('created_at', description='Field to sort by')
    direction: Direction | None = Field('desc', description='Sort direction')


class Pagination(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    limit: int | None = Field(50, description='Maximum number of tasks to return', ge=1, le=100)
    offset: int | None = Field(0, description='Number of tasks to skip', ge=0)


class TaskStatus(Enum):
    submitted = 'submitted'
    working = 'working'
    input_required = 'input-required'
    completed = 'completed'
    canceled = 'canceled'
    failed = 'failed'
    rejected = 'rejected'
    auth_required = 'auth-required'
    unknown = 'unknown'


class TaskType(Enum):
    create_media_buy = 'create_media_buy'
    update_media_buy = 'update_media_buy'
    sync_creatives = 'sync_creatives'
    activate_signal = 'activate_signal'
    get_signals = 'get_signals'


class Filters(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    domain: Domain | None = Field(None, description='Filter by single AdCP domain')
    domains: list[Domain] | None = Field(None, description='Filter by multiple AdCP domains')
    status: TaskStatus | None = Field(None, description='Filter by single task status')
    statuses: list[TaskStatus] | None = Field(None, description='Filter by multiple task statuses')
    task_type: TaskType | None = Field(None, description='Filter by single task type')
    task_types: list[TaskType] | None = Field(None, description='Filter by multiple task types')
    created_after: AwareDatetime | None = Field(
        None, description='Filter tasks created after this date (ISO 8601)'
    )
    created_before: AwareDatetime | None = Field(
        None, description='Filter tasks created before this date (ISO 8601)'
    )
    updated_after: AwareDatetime | None = Field(
        None, description='Filter tasks last updated after this date (ISO 8601)'
    )
    updated_before: AwareDatetime | None = Field(
        None, description='Filter tasks last updated before this date (ISO 8601)'
    )
    task_ids: list[str] | None = Field(
        None, description='Filter by specific task IDs', max_length=100
    )
    context_contains: str | None = Field(
        None,
        description='Filter tasks where context contains this text (searches buyer_ref, media_buy_id, signal_id, etc.)',
    )
    has_webhook: bool | None = Field(
        None, description='Filter tasks that have webhook configuration when true'
    )


class TasksListRequest(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    filters: Filters | None = Field(None, description='Filter criteria for querying tasks')
    sort: Sort | None = Field(None, description='Sorting parameters')
    pagination: Pagination | None = Field(None, description='Pagination parameters')
    include_history: bool | None = Field(
        False,
        description='Include full conversation history for each task (may significantly increase response size)',
    )
    context: dict[str, Any] | None = Field(
        None,
        description='Initiator-provided context included in the request payload. Agents must echo this value back unchanged in responses and webhooks. Use for UI/session hints, correlation tokens, or tracking metadata.',
    )
