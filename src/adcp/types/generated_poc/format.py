# generated by datamodel-codegen:
#   filename:  format.json
#   timestamp: 2025-11-15T17:40:24+00:00

from __future__ import annotations

from enum import Enum
from typing import Any

from adcp.types.base import AdCPBaseModel
from pydantic import AnyUrl, ConfigDict, Field


class Type(Enum):
    audio = 'audio'
    video = 'video'
    display = 'display'
    native = 'native'
    dooh = 'dooh'
    rich_media = 'rich_media'
    universal = 'universal'


class Responsive(AdCPBaseModel):
    width: bool
    height: bool


class Unit(Enum):
    px = 'px'
    dp = 'dp'
    inches = 'inches'
    cm = 'cm'


class Dimensions(AdCPBaseModel):
    width: float | None = Field(None, description='Fixed width in specified units', ge=0.0)
    height: float | None = Field(None, description='Fixed height in specified units', ge=0.0)
    min_width: float | None = Field(
        None, description='Minimum width for responsive renders', ge=0.0
    )
    min_height: float | None = Field(
        None, description='Minimum height for responsive renders', ge=0.0
    )
    max_width: float | None = Field(
        None, description='Maximum width for responsive renders', ge=0.0
    )
    max_height: float | None = Field(
        None, description='Maximum height for responsive renders', ge=0.0
    )
    responsive: Responsive | None = Field(
        None, description='Indicates which dimensions are responsive/fluid'
    )
    aspect_ratio: str | None = Field(
        None,
        description="Fixed aspect ratio constraint (e.g., '16:9', '4:3', '1:1')",
        pattern='^\\d+:\\d+$',
    )
    unit: Unit = Field(..., description='Unit of measurement for dimensions')


class Render(AdCPBaseModel):
    role: str = Field(
        ...,
        description="Semantic role of this rendered piece (e.g., 'primary', 'companion', 'mobile_variant')",
    )
    dimensions: Dimensions = Field(..., description='Dimensions for this rendered piece')


class AssetType(Enum):
    image = 'image'
    video = 'video'
    audio = 'audio'
    vast = 'vast'
    daast = 'daast'
    text = 'text'
    markdown = 'markdown'
    html = 'html'
    css = 'css'
    javascript = 'javascript'
    url = 'url'
    webhook = 'webhook'
    promoted_offerings = 'promoted_offerings'


class AssetsRequired(AdCPBaseModel):
    asset_id: str = Field(
        ...,
        description='Unique identifier for this asset. Creative manifests MUST use this exact value as the key in the assets object.',
    )
    asset_type: AssetType = Field(..., description='Type of asset')
    asset_role: str | None = Field(
        None,
        description="Optional descriptive label for this asset's purpose (e.g., 'hero_image', 'logo'). Not used for referencing assets in manifests—use asset_id instead. This field is for human-readable documentation and UI display only.",
    )
    required: bool | None = Field(None, description='Whether this asset is required')
    requirements: dict[str, Any] | None = Field(
        None,
        description='Technical requirements for this asset (dimensions, file size, duration, etc.)',
    )


class Repeatable(Enum):
    boolean_True = True


class Asset(AdCPBaseModel):
    asset_id: str = Field(..., description='Identifier for this asset within the group')
    asset_type: AssetType = Field(..., description='Type of asset')
    asset_role: str | None = Field(
        None,
        description="Optional descriptive label for this asset's purpose (e.g., 'hero_image', 'logo'). Not used for referencing assets in manifests—use asset_id instead. This field is for human-readable documentation and UI display only.",
    )
    required: bool | None = Field(
        None, description='Whether this asset is required in each repetition'
    )
    requirements: dict[str, Any] | None = Field(
        None, description='Technical requirements for this asset'
    )


class AssetsRequired1(AdCPBaseModel):
    asset_group_id: str = Field(
        ..., description="Identifier for this asset group (e.g., 'product', 'slide', 'card')"
    )
    repeatable: Repeatable = Field(..., description='Indicates this is a repeatable asset group')
    min_count: int = Field(..., description='Minimum number of repetitions required', ge=1)
    max_count: int = Field(..., description='Maximum number of repetitions allowed', ge=1)
    assets: list[Asset] = Field(..., description='Assets within each repetition of this group')


class FormatId(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    agent_url: AnyUrl = Field(
        ...,
        description="URL of the agent that defines this format (e.g., 'https://creatives.adcontextprotocol.org' for standard formats, or 'https://publisher.com/.well-known/adcp/sales' for custom formats)",
    )
    id: str = Field(
        ...,
        description="Format identifier within the agent's namespace (e.g., 'display_300x250', 'video_standard_30s')",
        pattern='^[a-zA-Z0-9_-]+$',
    )


class FormatCard(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    format_id: FormatId = Field(
        ..., description='Creative format defining the card layout (typically format_card_standard)'
    )
    manifest: dict[str, Any] = Field(
        ..., description='Asset manifest for rendering the card, structure defined by the format'
    )


class FormatCardDetailed(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    format_id: FormatId = Field(
        ...,
        description='Creative format defining the detailed card layout (typically format_card_detailed)',
    )
    manifest: dict[str, Any] = Field(
        ...,
        description='Asset manifest for rendering the detailed card, structure defined by the format',
    )


class Format(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    format_id: FormatId = Field(
        ..., description='Structured format identifier with agent URL and format name'
    )
    name: str = Field(..., description='Human-readable format name')
    description: str | None = Field(
        None,
        description='Plain text explanation of what this format does and what assets it requires',
    )
    preview_image: AnyUrl | None = Field(
        None,
        description='DEPRECATED: Use format_card instead. Optional preview image URL for format browsing/discovery UI. Should be 400x300px (4:3 aspect ratio) PNG or JPG. Used as thumbnail/card image in format browsers. This field is maintained for backward compatibility but format_card provides a more flexible, structured approach.',
    )
    example_url: AnyUrl | None = Field(
        None,
        description='Optional URL to showcase page with examples and interactive demos of this format',
    )
    type: Type = Field(
        ...,
        description='Media type of this format - determines rendering method and asset requirements',
    )
    renders: list[Render] | None = Field(
        None,
        description='Specification of rendered pieces for this format. Most formats produce a single render. Companion ad formats (video + banner), adaptive formats, and multi-placement formats produce multiple renders. Each render specifies its role and dimensions.',
        min_length=1,
    )
    assets_required: list[AssetsRequired | AssetsRequired1] | None = Field(
        None,
        description='Array of required assets or asset groups for this format. Each asset is identified by its asset_id, which must be used as the key in creative manifests. Can contain individual assets or repeatable asset sequences (e.g., carousel products, slideshow frames).',
    )
    delivery: dict[str, Any] | None = Field(
        None, description='Delivery method specifications (e.g., hosted, VAST, third-party tags)'
    )
    supported_macros: list[str] | None = Field(
        None,
        description='List of universal macros supported by this format (e.g., MEDIA_BUY_ID, CACHEBUSTER, DEVICE_ID). Used for validation and developer tooling.',
    )
    output_format_ids: list[FormatId] | None = Field(
        None,
        description='For generative formats: array of format IDs that this format can generate. When a format accepts inputs like brand_manifest and message, this specifies what concrete output formats can be produced (e.g., a generative banner format might output standard image banner formats).',
    )
    format_card: FormatCard | None = Field(
        None,
        description='Optional standard visual card (300x400px) for displaying this format in user interfaces. Can be rendered via preview_creative or pre-generated.',
    )
    format_card_detailed: FormatCardDetailed | None = Field(
        None,
        description='Optional detailed card with carousel and full specifications. Provides rich format documentation similar to ad spec pages.',
    )
