# generated by datamodel-codegen:
#   filename:  tasks-list-response.json
#   timestamp: 2025-11-15T17:41:30+00:00

from __future__ import annotations

from enum import Enum
from typing import Any

from adcp.types.base import AdCPBaseModel
from pydantic import AwareDatetime, ConfigDict, Field


class DomainBreakdown(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    media_buy: int | None = Field(
        None, alias='media-buy', description='Number of media-buy tasks in results', ge=0
    )
    signals: int | None = Field(None, description='Number of signals tasks in results', ge=0)


class Direction(Enum):
    asc = 'asc'
    desc = 'desc'


class SortApplied(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    field: str
    direction: Direction


class QuerySummary(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    total_matching: int = Field(
        ..., description='Total number of tasks matching filters (across all pages)', ge=0
    )
    returned: int = Field(..., description='Number of tasks returned in this response', ge=0)
    domain_breakdown: DomainBreakdown | None = Field(None, description='Count of tasks by domain')
    status_breakdown: dict[str, int] | None = Field(None, description='Count of tasks by status')
    filters_applied: list[str] | None = Field(
        None, description='List of filters that were applied to the query'
    )
    sort_applied: SortApplied | None = Field(None, description='Sort order that was applied')


class Domain(Enum):
    media_buy = 'media-buy'
    signals = 'signals'


class Pagination(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    limit: int = Field(..., description='Limit that was applied to this query', ge=1)
    offset: int = Field(..., description='Offset that was applied to this query', ge=0)
    has_more: bool = Field(..., description='Whether there are more tasks beyond this page')
    next_offset: int | None = Field(
        None, description='Offset to use for next page (only present if has_more is true)', ge=0
    )


class TaskType(Enum):
    create_media_buy = 'create_media_buy'
    update_media_buy = 'update_media_buy'
    sync_creatives = 'sync_creatives'
    activate_signal = 'activate_signal'
    get_signals = 'get_signals'


class TaskStatus(Enum):
    submitted = 'submitted'
    working = 'working'
    input_required = 'input-required'
    completed = 'completed'
    canceled = 'canceled'
    failed = 'failed'
    rejected = 'rejected'
    auth_required = 'auth-required'
    unknown = 'unknown'


class Task(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    task_id: str = Field(..., description='Unique identifier for this task')
    task_type: TaskType = Field(..., description='Type of AdCP operation')
    domain: Domain = Field(..., description='AdCP domain this task belongs to')
    status: TaskStatus = Field(..., description='Current task status')
    created_at: AwareDatetime = Field(
        ..., description='When the task was initially created (ISO 8601)'
    )
    updated_at: AwareDatetime = Field(..., description='When the task was last updated (ISO 8601)')
    completed_at: AwareDatetime | None = Field(
        None,
        description='When the task completed (ISO 8601, only for completed/failed/canceled tasks)',
    )
    has_webhook: bool | None = Field(
        None, description='Whether this task has webhook configuration'
    )


class TasksListResponse(AdCPBaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    query_summary: QuerySummary = Field(..., description='Summary of the query that was executed')
    tasks: list[Task] = Field(..., description='Array of tasks matching the query criteria')
    pagination: Pagination = Field(..., description='Pagination information')
    context: dict[str, Any] | None = Field(
        None,
        description='Initiator-provided context echoed inside the task payload. Opaque metadata such as UI/session hints, correlation tokens, or tracking identifiers.',
    )
