#!/usr/bin/env python3
"""
Create a consolidated export file that re-exports all types from generated_poc modules.

This script analyzes all modules in generated_poc/ and creates a single generated.py
that imports and re-exports all public types, handling naming conflicts appropriately.
"""

from __future__ import annotations

import ast
import time
from pathlib import Path

GENERATED_POC_DIR = Path(__file__).parent.parent / "src" / "adcp" / "types" / "generated_poc"
OUTPUT_FILE = Path(__file__).parent.parent / "src" / "adcp" / "types" / "generated.py"


def extract_exports_from_module(module_path: Path) -> set[str]:
    """Extract all public class and type alias names from a Python module."""
    with open(module_path) as f:
        try:
            tree = ast.parse(f.read())
        except SyntaxError:
            return set()

    exports = set()

    for node in ast.walk(tree):
        # Class definitions
        if isinstance(node, ast.ClassDef):
            if not node.name.startswith("_"):
                exports.add(node.name)
        # Module-level assignments (type aliases)
        elif isinstance(node, ast.Assign):
            for target in node.targets:
                if isinstance(target, ast.Name) and not target.id.startswith("_"):
                    # Only export if it looks like a type name (starts with capital)
                    if target.id[0].isupper():
                        exports.add(target.id)

    return exports


def generate_consolidated_exports() -> str:
    """Generate the consolidated exports file content."""
    # Discover all modules
    modules = sorted(GENERATED_POC_DIR.glob("*.py"))
    modules = [m for m in modules if m.stem != "__init__" and not m.stem.startswith(".")]

    print(f"Found {len(modules)} modules to consolidate")

    # Build import statements and collect all exports
    import_lines = []
    all_exports = set()

    for module_path in modules:
        module_name = module_path.stem
        exports = extract_exports_from_module(module_path)

        if not exports:
            continue

        print(f"  {module_name}: {len(exports)} exports")

        # Create import statement
        exports_str = ", ".join(sorted(exports))
        import_line = f"from adcp.types.generated_poc.{module_name} import {exports_str}"
        import_lines.append(import_line)

        all_exports.update(exports)

    # Generate file content
    lines = [
        '"""Generated AdCP types.',
        "",
        "Auto-generated by datamodel-code-generator from JSON schemas.",
        "DO NOT EDIT MANUALLY.",
        "",
        "Generated from: https://github.com/adcontextprotocol/adcp/tree/main/schemas",
        f"Generation date: {time.time()}",
        '"""',
        "",
        "from __future__ import annotations",
        "",
        "# Import all types from generated_poc modules",
    ]

    lines.extend(import_lines)

    lines.extend([
        "",
        "# Explicit exports",
        f"__all__ = {sorted(list(all_exports))}",
        ""
    ])

    return "\n".join(lines)


def main():
    """Generate consolidated exports file."""
    print("Generating consolidated exports from generated_poc modules...")

    if not GENERATED_POC_DIR.exists():
        print(f"Error: {GENERATED_POC_DIR} does not exist")
        return 1

    content = generate_consolidated_exports()

    print(f"\nWriting {OUTPUT_FILE}...")
    OUTPUT_FILE.write_text(content)

    print(f"âœ“ Successfully generated consolidated exports")
    export_count = len([name for name in content.split("__all__ = [")[1].split("]")[0].strip("[]").split(",") if name.strip()])
    print(f"  Total exports: {export_count}")

    return 0


if __name__ == "__main__":
    exit(main())
